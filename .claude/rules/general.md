承知いたしました。ご提示いただいたReactNative向けのCursorルールを、**AgriLens（Pure JavaScript/Node.js/Google Cloud）プロジェクト**の仕様に最適化し、より実践的な開発ルールとして再構築します。

ReactNative/Expo特有の項目を、Webアプリケーション（特に地図とAIを扱う）のアーキテクチャに合わせた内容に全面的に書き換えました。

---

## AgriLens 開発ルール・ベストプラクティス

### 基本思想
我々は、農業従事者に最高の営農支援体験を提供するため、**クリーンで、スケーラブルで、保守性の高いコード**を目指します。このシステムは、フロントエンド (Pure JavaScript)、バックエンド (Node.js)、外部サービス (Google Cloud) が連携する**クラシック・レイヤードアーキテクチャ**を採用します。このドキュメントは、そのための指針となるベストプラクティスと、チーム内での共通認識を明文化したものです。

---

### I. 全体的な開発原則 (普遍的なルール)

このセクションは普遍的な原則であり、AgriLensプロジェクトにおいても完全に適用されます。

1.  **シンプルさを追求する (Keep It Simple, Stupid - KISS):**
    *   複雑な解決策よりも、単純で理解しやすいコードを優先します。
    *   過度な抽象化や時期尚早な最適化は避けます。

2.  **DRY原則 (Don't Repeat Yourself):**
    *   同じロジックや情報は複数箇所に書かず、関数やモジュール、定数として共通化します。（例: `vegetation-indices.js`のような計算ロジック）
    *   ただし、無理な共通化による複雑性の増加には注意し、適度な重複は許容します。

3.  **YAGNI原則 (You Ain't Gonna Need It):**
    *   現時点で必要とされていない機能や汎用性は実装しません。将来必要になった時点で追加します。

4.  **SOLID原則の意識 (特に単一責任の原則 - SRP):**
    *   各モジュール、関数、ファイルは、一つの明確な責務を持つように設計します。（例: `map.js`は地図操作、`gemini-api.js`はAI通信に専念する）
    *   フロントエンド、バックエンド、各サービスレイヤーがこの原則に従うことを目指します。

5.  **明確な命名:**
    *   変数名、関数名、ファイル名は、その役割や内容を正確に表すようにします。
    *   曖昧な名前 (`data`, `obj`) や省略しすぎた名前は避けます。（例: `fetchGeeAnalysis` は `getAnalysis` より良い）
    *   真偽値を返す関数は `isFieldSelected`, `hasValidCredentials` のように接頭辞をつけます。

6.  **コメントは「なぜ」を書く:**
    *   コードが「何をしているか」はコード自体で示すべきです。
    *   **「なぜそのように実装したのか」「どのような背景や意図があるのか」**といった、コードからは読み取りにくい情報をコメントで補足します。
    *   特に、**外部APIの制約によるワークアラウンド**や、**特定のプロンプトチューニングの意図**には必ずコメントを残します。

7.  **早期リターンとガード節:**
    *   関数の冒頭で不正な引数や条件（例: 圃場が未選択、認証情報がない）をチェックし、早期にリターンすることで、ネストを浅く保ち、主要なロジックを読みやすくします。

8.  **イミュータビリティ (不変性) の活用:**
    *   可能な限り、データ構造（オブジェクトや配列）を直接変更せず、新しいインスタンスを作成して返すようにします（例: スプレッド構文 `{...obj}`, `Array.prototype.map`）。これにより、予期せぬ副作用を防ぎ、状態管理を簡潔にします。

9.  **エラーハンドリングの徹底:**
    *   **Google Cloud API呼び出し、ファイル操作など、失敗する可能性のある全ての処理**には、必ず適切なエラーハンドリング（`try...catch`、Promiseの`.catch()`）を実装します。
    *   ユーザーにエラーをフィードバックする方法（トースト通知、エラーメッセージ表示）と、開発者向けのエラーログ（`console.error`）を明確に区別します。
    *   仕様書にある**フォールバック機構**（例: 認証失敗時にモックデータを返す）は、システムの堅牢性を高めるための重要なパターンとして積極的に採用します。

10. **非同期処理の適切な扱い:**
    *   `async/await` を第一選択とし、コードの可読性を高めます。
    *   複数の非同期処理を並行して実行する場合は `Promise.all` や `Promise.allSettled` を適切に活用し、パフォーマンスを向上させます。
    *   **API呼び出しの `await` 忘れは、発見しにくいバグの温床となるため、細心の注意を払います。**

---

### II. AgriLens 特有のアーキテクチャとプラクティス

このセクションは、AgriLensの技術スタック（Pure JS/Node.js/Google Cloud）に特化したルールです。

1.  **フロントエンド (Pure JavaScript & Leaflet.js):**
    *   **モジュラー設計:** `js/modules/` 以下に、責務ごとにファイルを分割します。
        *   `map.js`: Leaflet.jsに関する操作（初期化, 描画, イベント）
        *   `api-client.js`: バックエンドとの通信を責務とするクライアント
        *   `ui.js`: DOM操作やUIコンポーネントの描画
        *   `state.js`: アプリケーションのグローバルな状態管理（選択中の圃場、分析結果など）
    *   **状態管理:** フレームワークがないため、状態は`state.js`のような専用モジュールで一元管理し、状態変更の副作用を予測しやすくします。
    *   **地図処理 (Leaflet.js):**
        *   パフォーマンスを意識し、大量のデータを表示する場合は `L.GeoJSON` の `onEachFeature` やマーカークラスタリングを検討します。
        *   レイヤー（衛星画像、圃場ポリゴンなど）はグループ管理し、表示/非表示の切り替えを容易にします。

2.  **バックエンド (Node.js & Express.js):**
    *   **ルーティングとコントローラーの分離:** Expressの `Router` を使い、機能ごと（例: `/api/analyze`, `/api/ai-advice`）にファイルを分割します。
    *   **サービスレイヤーの導入:** Expressのハンドラー（コントローラー）から、**Google Cloudとの連携などの複雑なビジネスロジックをサービスレイヤー (`services/`ディレクトリなど) に切り出します。**
    *   **環境変数管理 (`dotenv`):**
        *   **`process.env` を直接コード内で参照せず**、`config.js` のような設定ファイルで一元管理します。
        *   **`.env` ファイルは絶対にGitリポジトリにコミットしません。**`.env.example` を用意し、必要な環境変数を明記します。
    *   **セキュリティ:** `cors` やセッション管理 (`express-session`) は適切に設定し、本番環境でのセキュリティを担保します。

3.  **Google Cloud SDK の活用:**
    *   **SDKの初期化:** SDKのクライアントは、リクエスト毎に生成せず、モジュールのトップレベルで一度だけ初期化し、再利用します。
    *   **認証情報の安全な管理:** **サービスアカウントのJSONキーを直接コードに埋め込まず**、環境変数経由で読み込みます。本番環境では、Cloud RunやApp Engineの環境変数、またはSecret Managerを使用します。
    *   **Vertex AI 連携:**
        *   **プロンプト管理:** プロンプトは文字列としてコードに埋め込むのではなく、テンプレートリテラルや専用の管理ファイルに分離し、保守性を高めます。
        *   **JSONモードの活用:** AIに構造化データを生成させる場合は、Vertex AIの**JSONモード**を積極的に活用し、レスポンスの安定性を向上させます。
    *   **Google Earth Engine (GEE) 連携:**
        *   **サーバーサイド処理の徹底:** GEEの重い計算は必ずサーバーサイドで実行し、クライアントには結果の数値やタイルURLなど、必要最小限のデータのみを返します。
        *   **エラーハンドリング:** `ee.data.authenticateViaPrivateKey` のような非同期初期化処理のエラーも確実に捕捉します。

4.  **パフォーマンス考慮:**
    *   **AIレスポンスの体感速度:** AIの応答に時間がかかる場合は、**ストリーミング応答**を検討し、ユーザーが結果を待っている間に部分的な情報を表示します。
    *   **GEEの計算時間:** 複雑な分析には時間がかかることを想定し、フロントエンドにローディングインジケーターを必ず表示します。可能であれば、よく使われる領域の結果をキャッシュする仕組みを検討します。
    *   **画像/タイルデータ:** GEEから生成される地図タイルは、ブラウザキャッシュが効くように適切なHTTPヘッダーを設定します。

---

### III. 型安全性とデータバリデーション (TypeScript & Zod の導入推奨)

本プロジェクトは現在Pure JavaScriptですが、**将来のスケールと保守性向上のため、TypeScriptの導入を強く推奨します。** 以下のルールは、TypeScript導入を前提としつつ、JS環境でも部分的に適用可能です。

1.  **TypeScriptの導入:**
    *   **`tsconfig.json` では `strict: true` を有効にし**、TypeScriptの型チェック能力を最大限に活用します。
    *   **`any` 型の使用は原則禁止**します。どうしても必要な場合は理由をコメントし、スコープを最小限に留めます。外部からの未知のデータは `unknown` を使用します。

2.  **Zodによるデータバリデーションの徹底:**
    *   **思想:** Zodを**システムの外部境界における「門番」**として位置付けます。全ての外部データは、信頼する前にZodで検証・パースします。
    *   **適用箇所:**
        *   **バックエンド:**
            *   **Vertex AIからのAPIレスポンス:** AIが仕様通りのJSONを返しているか検証します。
            *   **GEEからの分析結果:** 期待するデータ構造（`ndvi`, `ndmi`など）になっているか検証します。
            *   **フロントエンドからのリクエストボディ:** `aoiGeoJSON` などが正しい形式か検証します。
        *   **フロントエンド:**
            *   **バックエンドからのAPIレスポンス:** これを検証することで、フロントエンドはバックエンドの変更に強くなります。
    *   **型生成 (`z.infer`):** バリデーションスキーマからTypeScriptの型を自動生成し、手動での型定義を不要にします。これにより、**スキーマと型が常に同期**し、型安全性が保証されます。

    **【AgriLensにおけるZodスキーマの具体例】**
    ```typescript
    // shared/types/ai-analysis.ts (フロントとバックで共有可能なスキーマ)
    import { z } from 'zod';

    // AIからのレスポンスを検証するスキーマ
    export const AiAnalysisResponseSchema = z.object({
      '重要な知見のまとめ': z.string().min(1),
      '詳細な評価': z.object({
        NDVI: z.object({ value: z.number(), text: z.string() }),
        NDMI: z.object({ value: z.number(), text: z.string() }),
        NDRE: z.object({ value: z.number(), text: z.string() }),
      }),
      '具体的な対策': z.array(z.string()),
      '今後の管理ポイント': z.array(z.string()),
    });

    // スキーマからTypeScriptの型を自動生成
    export type AiAnalysisResponse = z.infer<typeof AiAnalysisResponseSchema>;

    // バックエンドのサービスレイヤーでの使用例
    // import { AiAnalysisResponseSchema } from './shared/types/ai-analysis';
    //
    // async function getAiAdvice(prompt: string): Promise<AiAnalysisResponse> {
    //   const aiResponseJson = await vertexAiClient.generate(prompt); // レスポンスは unknown とする
    //
    //   try {
    //     // ここでパース＆バリデーション。成功すれば型安全なオブジェクトが返る
    //     const validatedData = AiAnalysisResponseSchema.parse(aiResponseJson);
    //     return validatedData;
    //   } catch (error) {
    //     if (error instanceof z.ZodError) {
    //       console.error("AIレスポンスの形式が不正です:", error.issues);
    //       // ここでフォールバック処理やエラー通知を行う
    //       throw new Error("AIからの応答を解析できませんでした。");
    //     }
    //     throw error;
    //   }
    // }
    ```

---

### IV. テスト (Jest)

品質を担保し、安全なリファクタリングを可能にするため、テストを記述します。

1.  **単体テスト (Unit Tests):**
    *   **対象:** 他のモジュールに依存しない、純粋なロジックを持つ関数。（例: `vegetation-indices.js` 内の各計算関数、プロンプト生成関数など）
    *   **目的:** 関数の入力と出力が正しいことを確認します。

2.  **統合テスト (Integration Tests):**
    *   **対象:** Expressのエンドポイント。複数のモジュールが連携する機能。
    *   **目的:** APIがリクエストを受け取り、意図したレスポンス（成功時、エラー時）を返すことを確認します。
    *   **ツール:** `supertest` などのライブラリの利用を推奨します。

3.  **モックの活用:**
    *   **Google Cloud SDKや外部APIへのリクエストは必ずモックします。**これにより、テストが外部要因（ネットワーク、API利用料、認証）に依存せず、高速かつ安定して実行できます。
    *   Jestの `jest.mock()` や `jest.spyOn()` を活用します。