## AgriLens 開発ルール・ベストプラクティス (JavaScript版)

### 基本思想
我々は、農業従事者に最高の営農支援体験を提供するため、**シンプルで、読みやすく、保守しやすいコード**を目指します。このシステムは、フロントエンド (Pure JavaScript)、バックエンド (Node.js)、外部サービス (Google Cloud) が連携して動作します。このドキュメントは、そのための指針となるベストプラクティスと、チーム内での共通認識を明文化したものです。

---

### I. 全体的な開発原則

1.  **シンプルさを追求する (Keep It Simple, Stupid - KISS):**
    *   複雑な解決策よりも、単純で理解しやすいコードを優先します。
    *   将来必要になるかもしれない、といった推測に基づく過剰な機能実装は避けます。

2.  **DRY原則 (Don't Repeat Yourself):**
    *   同じ計算ロジックや設定値は、関数や定数として共通化し、再利用します。（例: `vegetation-indices.js` の計算式）
    *   ただし、共通化によってコードが逆に複雑になる場合は、無理に行う必要はありません。

3.  **YAGNI原則 (You Ain't Gonna Need It):**
    *   「いつか必要になるだろう」という機能は実装しません。現時点で必要な機能だけを実装します。

4.  **役割分担を明確にする (単一責任の原則):**
    *   各ファイルや関数は、一つの明確な役割を持つように設計します。（例: `map.js`は地図の操作、`gemini-api.js`はAIとの通信に専念する）
    *   これにより、コードの変更箇所が特定しやすくなり、修正が容易になります。

5.  **明確な命名:**
    *   変数名、関数名、ファイル名は、その役割や内容が一目でわかるようにします。
    *   `data`, `temp`, `obj` のような曖昧な名前は避け、`fieldData`, `analysisResult` のように具体的にします。
    *   真偽値（true/false）を返す関数には `isFieldSelected`, `hasValidCredentials` のように `is` や `has` を付けます。

6.  **コメントは「なぜ」を書く:**
    *   コードが「何をしているか」は、コード自体で表現すべきです。
    *   コメントには、**「なぜこの方法を選んだのか」「どのような背景や意図があるのか」**といった、コードから読み取れない情報を書きます。
    *   特に、**外部APIの制約による特別な処理**や、**AIへのプロンプトを調整した意図**などには、必ずコメントを残しましょう。

7.  **早期リターンとガード節:**
    *   関数の冒頭で、処理を続けられない条件（例: 必要なデータがない）をチェックし、すぐに処理を終了させます。これにより、コードのネストが深くなるのを防ぎ、メインの処理が読みやすくなります。
    ```javascript
    function analyzeField(field) {
      if (!field) {
        console.error("分析対象の圃場がありません。");
        return; // すぐに処理を終了
      }
      // ... メインの分析処理 ...
    }
    ```

8.  **エラーハンドリングの徹底:**
    *   **Google Cloud APIの呼び出しなど、失敗する可能性のある全ての処理**には、必ず `try...catch` を使ってエラーを捕捉します。
    *   ユーザーには分かりやすいエラーメッセージ（例: 「AIとの通信に失敗しました」）を表示し、開発者向けにはコンソールに詳細なエラー情報を出力します。
    *   仕様書にある**フォールバック機構**（例: 認証エラー時にモックデータを表示する）は、システムの安定性を高めるために積極的に採用します。

9.  **非同期処理の適切な扱い:**
    *   `async/await` を基本とし、非同期処理を同期的で読みやすいコードのように記述します。
    *   複数のAPI呼び出しを同時に行える場合は `Promise.all` を使い、処理時間を短縮します。
    *   **`await` の付け忘れは、バグの大きな原因になります。**API呼び出しなどの非同期関数を実行する際は、常に注意してください。

---

### II. AgriLens 特有の構造とプラクティス

1.  **フロントエンド (Pure JavaScript & Leaflet.js):**
    *   **ファイル分割:** 機能ごとにファイルを分割し、見通しを良くします。
        *   `map.js`: Leaflet地図の初期化、描画、イベント操作
        *   `api.js`: バックエンドAPIとの通信処理
        *   `ui.js`: DOM操作、UIの更新、イベントリスナーの設定
        *   `main.js` または `app.js`: アプリケーション全体の初期化と、各モジュールの連携
    *   **状態管理:** アプリケーション全体で共有するデータ（例: 選択中の圃場、最新の分析結果）は、特定のオブジェクトや変数で管理し、どこでデータが変更されるかを明確にします。

2.  **バックエンド (Node.js & Express.js):**
    *   **機能ごとのファイル分割:** Expressの `Router` を使い、APIの機能ごと（例: `/api/analyze`, `/api/ai-advice`）にファイルを分け、`server.js` が肥大化するのを防ぎます。
    *   **ロジックの分離:** ExpressのAPIエンドポイントの処理（リクエストを受け取り、レスポンスを返す部分）と、**Google Cloudとの通信のような複雑な処理は、別の関数やファイルに分離します。**
    *   **環境変数管理 (`dotenv`):**
        *   APIキーや認証情報などの秘密情報は、`.env` ファイルに記述します。
        *   **`.env` ファイルは絶対にGitで管理しません。** 代わりに、必要な設定項目を記載した `.env.example` ファイルを用意します。
        *   コード内では `process.env` を通じて設定値を読み込みます。

3.  **Google Cloud連携:**
    *   **安全な認証:** **サービスアカウントのキー（JSONファイル）をコードに直接書き込まず**、環境変数として読み込みます。
    *   **プロンプト管理:** AIに送るプロンプト（指示文）が長くなる場合は、コードから分離して別のテキストファイルや専用のJSファイルで管理すると、見通しが良くなります。
    *   **サーバーサイド処理の徹底 (Earth Engine):** 地図データの重い計算は必ずサーバー側で行い、ブラウザには分析結果の数値や画像URLなど、軽量なデータだけを送ります。

---

### III. データの検証と一貫性の確保

外部（AI、API、ユーザー入力）から受け取るデータは、常に期待通りの形式であるとは限りません。プログラムが予期せぬエラーで停止しないよう、データを受け取った直後に中身を検証する習慣をつけます。

1.  **AIレスポンスの検証:**
    *   AI（Gemini/Gemma）からの応答は、プロンプトでJSON形式を指示していても、稀に形式が崩れることがあります。
    *   **必ず、期待するプロパティが存在するか、型が正しいかをチェックしてから使用します。**
    ```javascript
    // ai-chat.js での検証例
    try {
      const aiResult = await response.json();
      const analysis = aiResult.result; // AIの応答オブジェクト

      // 防御的なチェック
      if (!analysis || typeof analysis['詳細な評価'] !== 'object') {
        throw new Error("AIの応答形式が不正です。");
      }

      const ndviText = analysis['詳細な評価'].NDVI.text;
      // この時点で ndviText は安全に使える
      updateUiWithAnalysis(ndviText);

    } catch (error) {
      console.error("AI応答の処理に失敗しました:", error);
      showToast("エラー", "AIからの応答を解析できませんでした。");
    }
    ```

2.  **バリデーション関数の作成:**
    *   繰り返し使う検証ロジックは、専用の関数にまとめると便利です。
    ```javascript
    // modules/validator.js
    function isValidAnalysisData(data) {
      if (!data) return false;
      if (typeof data.ndvi !== 'number') return false;
      if (typeof data.ndmi !== 'number') return false;
      if (typeof data.ndre !== 'number') return false;
      return true;
    }
    ```

3.  **入力値のサニタイズ:**
    *   ユーザーが入力したテキストをHTMLとして表示する場合は、クロスサイトスクリプティング（XSS）攻撃を防ぐため、必ずエスケープ処理（特殊文字を無害化する処理）を行ってください。

---

### IV. テスト (Jest)

品質を保ち、安心してコードを修正・追加できるように、テストを導入します。

1.  **単体テスト:**
    *   **対象:** 他に依存しない、独立した純粋な関数。（例: `vegetation-indices.js` の計算関数、プロンプトを生成する関数など）
    *   **目的:** 関数が正しい入力に対して、期待通りの出力を返すことを確認します。

2.  **APIエンドポイントのテスト:**
    *   **対象:** Expressで作成したAPIエンドポイント (`/api/analyze` など）。
    *   **目的:** APIがリクエストを受け付け、正しいステータスコードとデータを返すかを確認します。
    *   **モックの活用:** テスト実行時に、**実際にGoogle CloudのAPIを呼び出すのではなく、偽の応答を返す「モック」を使用します。** これにより、テストが速く、安定し、費用もかかりません。 Jestの `jest.mock()` 機能などを活用します。